#######################################################################
# Macro Manager
# 
# A klipper handler module for easy scheduling of delayed G-Code macros
#######################################################################


[gcode_macro _MACRO_MANAGER]
variable_active: False			# State variable for checking if any tasks are activly waiting execution
variable_task_library: {}		# Dictionary object to hold tasks
variable_check_frequency: 2		# How often the task condition should be checked in seconds
gcode:
    {% set name = params.NAME|default(None) %}
	{% set command = params.COMMAND|default(None) %}
    {% set condition = params.CONDITION|default(None) %}
	{% set task_library = printer['gcode_macro _MACRO_MANAGER'].task_library %}
	{% set check_frequency = printer['gcode_macro _MACRO_MANAGER'].check_frequency %}
	{% set timeout = ((params.TIMEOUT|default(1800)|int)/check_frequency)|round(0, 'ceil')|int %}
	
	# Build the task from provided paramaters
	{% set task = {'name': name, 'command': command, 'condition': condition, 'predecessor': predecessor, 'timeout': timeout} %}
	
	# Check task and raise errors for misconfigurations
	{% if name == None %} {action_raise_error('_MACRO_MANAGER Macro - Task Name paramater not provided')} {% endif %}
	{% if command == None %} {action_raise_error('_MACRO_MANAGER Macro - Task command paramater not provided')} {% endif %}
	{% for task, task_paramaters in task_library.items() %}
		{% if task_paramaters['name'] == name %} {action_raise_error('_MACRO_MANAGER Macro - Task Name is not unique')} {% endif %}
	{% endfor %}
	
	# Load the new task to the task library
	{% if task_library|count == 0 %}
		{% set task_library = {1: task} %}
	{% else %}
		{% set task_library = printer['gcode_macro _MACRO_MANAGER'].task_library %}
		{% set new_task = {(task_library.keys()|max + 1): task} %}
		{% set _ = task_library.update(new_task) %}
	{% endif %}
	
	# Update the task library
	SET_GCODE_VARIABLE MACRO=_MACRO_MANAGER VARIABLE=task_library VALUE="{task_library | pprint | replace("\n", "") | replace("\"", "\\\"")}"
	
	# Display the dictonary
	{action_respond_info("Task Library: %s" % (task_library | pprint | replace("\n", "") | replace("\"", "\\\"")))}
	
	# Set state to active
	SET_GCODE_VARIABLE MACRO=_MACRO_MANAGER VARIABLE=active VALUE=True
	
	# Call the delayed wait loop macro
	UPDATE_DELAYED_GCODE ID=_MACRO_MANAGER_LOOP DURATION=0  # cancel any pending run
	UPDATE_DELAYED_GCODE ID=_MACRO_MANAGER_LOOP DURATION={check_frequency}


[delayed_gcode _MACRO_MANAGER_LOOP]
gcode:
	{% set task_library = printer['gcode_macro _MACRO_MANAGER'].task_library %}
	{% set check_frequency = printer['gcode_macro _MACRO_MANAGER'].check_frequency %}
	{% set tasks_to_remove = [] %}

	RESPOND MSG='Looping...'
	
	# Iterate over tasks in the task library
	{% for task, task_paramaters in task_library.items() %}
		{% if task_paramaters['timeout'] == 0 %}
			RESPOND MSG="Timeout reached for Task: {task_paramaters['name']}"
			{task_paramaters['command']}
			{% set _ = tasks_to_remove.append(task) %}
		{% else %}
			{% if task_paramaters['condition'] is not none %}    # Check if the task has a condition to evaluate
				{% if task_paramaters['condition'] == True %}    # Evaluate the condition
					{task_paramaters['command']}
					RESPOND MSG="Condition is True for Task: {task_paramaters['name']}"
					{% set _ = tasks_to_remove.append(task) %}   # Add the task to the task removal list
				{% endif %}
			{% endif %}
			
			# Decrement the task timout value
			{% set _ = task_library[task].update([('timeout', (task_paramaters['timeout'] - 1))]) %}
		{% endif %}
	{% endfor %}
	
	# Display tasks to remove
	#{action_respond_info("Tasks to Remove: %s" % (tasks_to_remove | pprint | replace("\n", "") | replace("\"", "\\\"")))}
	
	# Display the dictonary
	#{action_respond_info("Task Library: %s" % (task_library | pprint | replace("\n", "") | replace("\"", "\\\"")))}
	
	# Remove any tasks for completed tasks
	{% for item in tasks_to_remove %}
		{% set _ = task_library.pop(item) %}
	{% endfor %}
	
	#Update the task library
	SET_GCODE_VARIABLE MACRO=_MACRO_MANAGER VARIABLE=task_library VALUE="{task_library | pprint | replace("\n", "") | replace("\"", "\\\"")}"
	
	# If tasks are remaining, run loop again.  If not, end loop.
	{% if task_library|count == 0 %}
		# Cancel any pending run
		UPDATE_DELAYED_GCODE ID=_MACRO_MANAGER_LOOP DURATION=0
		# Set state to inactive
		SET_GCODE_VARIABLE MACRO=_MACRO_MANAGER VARIABLE=active VALUE=False
	{% else %}
		# Call the delayed wait loop macro
		UPDATE_DELAYED_GCODE ID=_MACRO_MANAGER_LOOP DURATION={check_frequency}
		## dwell for 1ms to prevent from going idle
        G4 P1
	{% endif %}
	
	
[gcode_macro _MACRO_MANAGER_STOP]
gcode:
	# Cancel any pending run
	UPDATE_DELAYED_GCODE ID=_MACRO_MANAGER_LOOP DURATION=0
	# Clear the task library
	{% set task_library = printer['gcode_macro _MACRO_MANAGER'].task_library %}
	{% set _ = task_library.clear() %}
	# Set state to inactive
	SET_GCODE_VARIABLE MACRO=_MACRO_MANAGER VARIABLE=active VALUE=False
	# Display the dictonary
	{action_respond_info("Task Library Cleared: %s" % (task_library | pprint | replace("\n", "") | replace("\"", "\\\"")))}
	

[gcode_macro TEST_ACTION]
variable_test_condition: False
gcode:
	{% set test_condition = printer['gcode_macro TEST_ACTION'].test_condition %}
	{% set toggle = params.TOGGLE|default(None) %}
	
	{% if toggle != None and test_condition %}
		{% set new_condition = False %}
		M118 Toggle to False
		SET_GCODE_VARIABLE MACRO=TEST_ACTION VARIABLE=test_condition VALUE={new_condition}
	{% elif toggle != None and not test_condition %}
		{% set new_condition = True %}
		M118 Toggle to True
		SET_GCODE_VARIABLE MACRO=TEST_ACTION VARIABLE=test_condition VALUE={new_condition}
	{% else %}
		M118 Action Executed
	{% endif %}